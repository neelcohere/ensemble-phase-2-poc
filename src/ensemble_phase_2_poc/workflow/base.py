# Base class for LangGraph workflows that integrate with Databricks/mlflow.
#
# Developers subclass this and only implement build_workflow() - all the
# request/response serialization and agent invocation is handled here.
#
# Generated by Claude Opus 4.5

from abc import ABC, abstractmethod
from typing import Any

from langgraph.graph import StateGraph
from langgraph.graph.state import CompiledStateGraph
from mlflow.pyfunc import ResponsesAgent
from mlflow.types.responses import ResponsesAgentRequest, ResponsesAgentResponse

from ensemble_phase_2_poc.state import WorkflowState, get_node_output


class LangGraphResponsesAgent(ResponsesAgent, ABC):
    """
    Base class for LangGraph workflows that integrate with Databricks/mlflow.

    Subclasses only need to implement:
    - build_workflow(): Define your StateGraph with nodes and edges

    The base class handles:
    - Compiling the workflow
    - Serializing ResponsesAgentRequest -> WorkflowState
    - Invoking the agent
    - Serializing final state -> ResponsesAgentResponse

    Example:
    ```
        class MyWorkflow(LangGraphResponsesAgent):
            def build_workflow(self) -> StateGraph:
                graph = StateGraph(WorkflowState)
                graph.add_node(...)
                graph.add_edge(...)
                return graph
    ```
    """

    _compiled_agent: CompiledStateGraph | None = None

    @property
    def agent(self) -> CompiledStateGraph:
        """Lazily compile the workflow on first access."""
        if self._compiled_agent is None:
            self._compiled_agent = self.build_workflow().compile()
        return self._compiled_agent

    @abstractmethod
    def build_workflow(self) -> StateGraph:
        """Define the workflow graph. Subclasses must implement this."""
        ...

    def predict(self, request: ResponsesAgentRequest) -> ResponsesAgentResponse:
        """Main entry point for Databricks/mlflow integration."""
        # Convert request to initial state
        initial_state = self._request_to_state(request)

        # Run the workflow
        final_state = self.agent.invoke(initial_state)

        # Convert final state to response
        return self._state_to_response(final_state)

    def _request_to_state(self, request: ResponsesAgentRequest) -> WorkflowState:
        """Convert ResponsesAgentRequest to WorkflowState"""
        custom_inputs = request.custom_inputs or {}

        return WorkflowState(
            node_outputs={},
            execution_path=[],
            account_number=custom_inputs.get("account_number", ""),
            client_name=custom_inputs.get("client_name", ""),
            facility_prefix=custom_inputs.get("facility_prefix", ""),
            lob=custom_inputs.get("lob", ""),
        )

    def _state_to_response(
        self,
        final_state: WorkflowState,
    ) -> ResponsesAgentResponse:
        """Convert final WorkflowState to ResponsesAgentResponse"""
        # Get the last executed node's output
        execution_path = final_state.get("execution_path", [])

        return ResponsesAgentResponse(
            output=[],
            custom_outputs={
                # Global parameters
                "account_number": final_state.get("account_number", ""),
                "client_name": final_state.get("client_name", ""),
                "facility_prefix": final_state.get("facility_prefix", ""),
                "lob": final_state.get("lob", ""),
                # Execution details
                "execution_path": execution_path,
                "node_outputs": {
                    node_id: get_node_output(final_state, node_id)
                    for node_id in execution_path
                },
            },
        )
